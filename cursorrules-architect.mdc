# Cursor Rules - Portfolio Architecture

## Project Overview
This is a modern React portfolio website built with TypeScript, SCSS, and follows a component-based architecture. The project showcases professional experience, skills, and projects in a clean, responsive design.

## Architecture Principles

### 1. Modular Component Structure
- **Component Organization**: Components are organized by feature/domain (home, skills, experience, projects)
- **File Structure**: Each component has its own directory with `.tsx` and `.scss` files
- **Separation of Concerns**: Logic, styling, and data are separated into appropriate files
- **Maximum File Size**: No file should exceed ~250 lines of code

### 2. Data Management
- **Type Safety**: All data structures are defined with TypeScript interfaces
- **Data Separation**: Data is stored in dedicated `data/` directories by feature
- **Type Definitions**: Each data module has corresponding `.types.ts` files

### 3. Styling Architecture
- **SCSS Organization**: 
  - Global styles in `styles/` directory
  - Component-specific styles co-located with components
  - Use of variables, mixins, and base styles
- **Responsive Design**: Mobile-first approach with proper breakpoints
- **CSS Methodology**: BEM-like naming conventions for maintainability

### 4. Routing Structure
- **File-based Routing**: Routes are organized by feature with dynamic segments
- **Nested Routes**: Skills and projects have nested routing for detailed views
- **404 Handling**: Proper error handling for unknown routes

## Code Standards

### TypeScript Guidelines
- **Strict Type Checking**: Enable strict mode in `tsconfig.json`
- **Interface Definitions**: Define clear interfaces for all data structures
- **Type Imports**: Use proper import/export patterns for types
- **Component Props**: Always type component props explicitly

### React Best Practices
- **Functional Components**: Use functional components with hooks
- **Component Composition**: Favor composition over inheritance
- **Props Interface**: Define clear prop interfaces for each component
- **State Management**: Use appropriate state management patterns

### SCSS Best Practices
- **Variable Usage**: Use SCSS variables for colors, fonts, and spacing
- **Mixins**: Create reusable mixins for common patterns
- **Nesting**: Limit nesting depth to maintain readability
- **Modular Styles**: Keep styles modular and component-specific

## File Organization Rules

### Component Structure
```
components/
├── [feature]/
│   ├── [sub-component]/
│   │   ├── ComponentName.tsx
│   │   └── ComponentName.scss
│   └── index.ts (if needed)
```

### Data Structure
```
data/
├── [feature]/
│   ├── [feature].data.ts
│   └── [feature].types.ts
```

### Route Structure
```
routes/
├── [feature].tsx
├── [feature]/
│   ├── index.tsx
│   ├── [id].tsx
│   └── [feature].scss
```

## Development Guidelines

### 1. Component Creation
- Create new components in appropriate feature directories
- Always include both `.tsx` and `.scss` files
- Define TypeScript interfaces for props and data
- Add proper comments explaining component purpose

### 2. Styling Guidelines
- Use semantic class names that describe purpose, not appearance
- Leverage SCSS variables for consistent theming
- Implement responsive design with mobile-first approach
- Use flexbox/grid for layout, avoid float-based layouts

### 3. Data Management
- Define clear TypeScript interfaces for all data structures
- Separate data from presentation logic
- Use descriptive naming for data properties
- Implement proper error handling for data operations

### 4. Performance Considerations
- Optimize images and assets
- Use lazy loading for route components
- Implement proper code splitting
- Minimize bundle size with tree shaking

## Code Quality Standards

### Comments and Documentation
- Add header comments to each file describing its purpose
- Document complex logic and algorithms
- Use JSDoc comments for public APIs
- Keep comments up-to-date with code changes

### Error Handling
- Implement proper error boundaries
- Handle loading and error states in components
- Provide meaningful error messages
- Log errors appropriately for debugging

### Testing Considerations
- Write testable components with clear interfaces
- Separate business logic from presentation
- Use proper mocking for external dependencies
- Maintain high test coverage for critical paths

## Asset Management

### Image Organization
- Store images in `public/images/` with feature-based subdirectories
- Use appropriate image formats (WebP, PNG, SVG)
- Implement proper image optimization
- Use descriptive filenames for assets

### Icon Management
- Centralize icons in `data/icons.tsx`
- Use SVG icons for scalability
- Implement proper icon components
- Maintain consistent icon styling

## Build and Deployment

### Development Workflow
- Use modern build tools (Vite, Webpack, etc.)
- Implement hot reloading for development
- Use proper environment configuration
- Maintain clean build outputs

### Production Optimization
- Minify CSS and JavaScript
- Optimize images and assets
- Implement proper caching strategies
- Use CDN for static assets when appropriate

## Security Considerations

### Content Security
- Sanitize user inputs
- Implement proper XSS protection
- Use HTTPS for all external resources
- Validate all external data sources

### Performance Security
- Implement proper CSP headers
- Use secure authentication patterns
- Avoid exposing sensitive information
- Regular security audits

## Maintenance Guidelines

### Code Refactoring
- Regular code reviews and refactoring
- Remove unused code and dependencies
- Update dependencies regularly
- Maintain backward compatibility when possible

### Documentation Updates
- Keep README.md current
- Update component documentation
- Maintain API documentation
- Document breaking changes

## Future Considerations

### Scalability
- Design for future feature additions
- Implement proper state management patterns
- Plan for internationalization if needed
- Consider micro-frontend architecture for large projects

### Technology Updates
- Stay current with React and TypeScript updates
- Evaluate new tools and libraries regularly
- Plan migration strategies for major updates
- Maintain compatibility with modern browsers

---

*This document should be updated as the project evolves and new architectural decisions are made.*